# CS-410-Software-Reverse-Engineering

This repository contains assignments and projects from the CS-410 Software Reverse Engineering course. During this course, we explored how a computer interprets code by converting C++ code into binary and assembly, focusing on how to reverse-engineer assembly and binary code back into high-level C++ code.

## Course Overview

In CS-410, we examined software reverse engineering using assembly language. The course focused on converting C++ code to assembly and binary, understanding how a computer processes and executes this code, and reversing it to analyze the original high-level programming logic. By the end of the course, we gained insights into low-level programming, security, and system optimization.

## Journal Summaries

### **Module 3 Journal - Zachary Nicholas**

**Overview & Purpose:**  
The journal explores software requirements engineering, its importance in the software development life cycle (SDLC), and its relation to reverse engineering. It also discusses the potential benefits of combining requirements engineering with reverse engineering.

**Key Points:**

- **Software Requirements Engineering:** A process to define, document, and maintain software requirements, including five stages: feasibility study, elicitation, specifications, verification and validation, and management.
- **Importance in SDLC:** Ensures that software is optimized for hardware and user needs, avoiding design flaws.
- **Comparison with Reverse Engineering:** Requirements engineering defines new project goals, while reverse engineering analyzes existing systems. They can complement each other, especially for legacy systems.
- **Round-Trip Engineering:** Combining both approaches can improve system optimization, documentation, and future upgrades.

### **Module 6 Journal - Zachary Nicholas**

**Overview & Purpose:**  
This journal discusses security vulnerabilities, particularly in C++ programming and legacy systems, and how they can be mitigated. It emphasizes the importance of identifying and fixing vulnerabilities using tools and testing methods.

**Key Points:**

- **Security Vulnerabilities:** Flaws in systems that can be exploited, such as buffer overflows, memory errors, unvalidated inputs, and injection attacks.
- **Legacy Systems:** Legacy systems often have vulnerabilities that need updating. Examples include the Colonial Pipeline hack and OPM data breach.
- **Fixing Vulnerabilities:** Tools like OWASP and NIST guidelines help identify and mitigate vulnerabilities through techniques like black-box and white-box testing.

### **Module 7 Journal - Zachary Nicholas**

**Overview & Purpose:**  
This journal explores the Digital Millennium Copyright Act (DMCA), its implications for reverse engineering, and its long-term impact on computer science and digital rights.

**Key Points:**

- **DMCA Purpose:** Aims to address digital-era issues, particularly the removal of unauthorized copyrighted material.
- **Anti-Reverse Engineering:** The DMCA prevents the circumvention of digital protection measures, making it an anti-reverse engineering law, though it allows for certain exceptions.
- **Exceptions:** Legal exceptions include interoperability, security research, compatibility testing, and fixing vulnerabilities.
- **Personal Perspective:** The DMCA balances copyright protection with enabling ethical reverse engineering practices, fostering improvements in software, compatibility, and security.

## Repository Structure

- `Assignment 1 C++ to assembly/`: Tasks on converting C++ code to assembly language.
- `Assignment 2 Assembly to C++/`: Tasks on converting assembly code back to C++.
- `Assignment 3 Binary to Assembly/`: Exercises on converting binary code to assembly.
- `Assignment 4 Binary to C++/`: Tasks focused on reconstructing C++ code from binary representations.
- `Project 1/` and `Project 2/`: Capstone projects showcasing reverse engineering skills.
- `Journals/`: Personal reflections and analyses of course topics.
